{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Omnigres","text":"<p>Omnigres makes PostgreSQL a complete application platform. You can deploy a single database instance and it can host your entire application, scaling as needed.</p> <ul> <li>Running application logic inside or next to the database instance</li> <li>Deployment provisioning (Git, Docker, etc.)</li> <li>Database instance serves HTTP, WebSocket and other protocols</li> <li>In-memory and volatile on-disk caching</li> <li>Routine application building blocks (authentication, authorization, payments, etc.)</li> <li>Database-modeled application logic via reactive queries</li> <li>Automagic remote APIs and form handling</li> <li>Live data updates</li> </ul>"},{"location":"quick_start/","title":"Quick Start","text":"<p>The fastest way to try Omnigres out is by using its container image:</p> <pre><code>docker volume create omnigres\ndocker run --name omnigres -e POSTGRES_PASSWORD=omnigres -e POSTGRES_USER=omnigres \\\n-e POSTGRES_DB=omnigres --mount source=omnigres,target=/var/lib/postgresql/data \\\n-p 5432:5432 -p 8080:8080 --rm ghcr.io/omnigres/omnigres:latest\n# Now you can connect to it:\npsql -h localhost -p 5432 -U omnigres omnigres # password is `omnigres`\n</code></pre> <p>You can access the HTTP server at localhost:8080</p>"},{"location":"quick_start/#building-your-own-image","title":"Building your own image","text":"<p>If you can't use the pre-built image (for example, you are running a fork or made changes), you can build the image yourself:</p> <pre><code># Build the image\nDOCKER_BUILDKIT=1 docker build . -t ghcr.io/omnigres/omnigres\n</code></pre>"},{"location":"Dynpgext/intro/","title":"Intro","text":"<p>Dynamic Postgres Extensions interface enables upgrading/downgrading Postgres extensions that allocate and use shared memory and start dynamic background workers proactively.</p>"},{"location":"Dynpgext/usage/","title":"Usage","text":"<p>To make your extension use the interface, include the header file and declare magic signature:</p> <pre><code>#include &lt;dynpgext.h&gt;\nDYNPGEXT_MAGIC;\n</code></pre>"},{"location":"Dynpgext/usage/#allocating-shared-memory","title":"Allocating shared memory","text":"<p>You can request shared memory in <code>_Dynpgext_init</code> callback you can define:</p> Shared memory allocation<pre><code>void _Dynpgext_init(const dynpgext_handle *handle) {\nhandle-&gt;allocate_shmem(handle, /* name */ \"my_ext:0.1:value\", /* size */ 1024,\n/* callback */ cb, /* callback payload */ NULL,\n/* flags */ DYNPGEXT_SCOPE_DATABASE_LOCAL /* or DYNPGEXT_SCOPE_GLOBAL */);\n}\n</code></pre> <p>A particularly useful feature is the ability to scope the allocation per database so that every database provisioned will get its own allocation of the specified size.</p> <p>Once allocated, the pointer to allocated memory can be found using <code>dynpgext_lookup_shmem(name)</code>:</p> <pre><code>void *ptr = dynpgext_lookup_shmem(\"my_ext:0.1:value\");\n</code></pre>"},{"location":"Dynpgext/usage/#registering-background-worker","title":"Registering background worker","text":"<p>You can register a background worker to be started in `_Dynpgext_init:</p> Background worker registration<pre><code>BackgroundWorker bgw = {.bgw_name = \"worker\",\n.bgw_type = \"worker\",\n.bgw_function_name = \"worker\",\n.bgw_flags = BGWORKER_SHMEM_ACCESS,\n.bgw_start_time = BgWorkerStart_RecoveryFinished};\nstrncmp(bgw.bgw_library_name, handle-&gt;library_name, BGW_MAXLEN);\nhandle-&gt;register_bgworker(handle, &amp;bgw, NULL, NULL,\nDYNPGEXT_REGISTER_BGWORKER_NOTIFY | DYNPGEXT_SCOPE_GLOBAL /* can also take DYNPGEXT_SCOPE_DATABASE_LOCAL */);\n</code></pre> <p>Just like shared memory allocations, background workers can be either global or provisioned per database.</p>"},{"location":"examples/motd/","title":"MOTD service","text":"<p>Below is a simple web application that runs inside of Postgres and manages MOTD (Message Of The Day).</p> <p>All you need to run this is just an instance of Postgres with Omnigres extensions (omni_httpd and omni_web) installed.</p> <pre><code>create table if not exists motd -- (1)\n(\nid        int primary key generated always as identity,\ncontent   text,\nposted_at timestamp default now()\n);\n-- (2)\ncreate or replace function show_motd() returns setof omni_httpd.http_response as\n$$\nselect\nomni_httpd.http_response('Posted at ' || posted_at || E'\\n' || content)\nfrom\nmotd\norder by\nposted_at desc\nlimit 1;\n$$ language sql;\n-- (3)\ncreate or replace function no_motd() returns setof omni_httpd.http_response as\n$$\nselect omni_httpd.http_response('No MOTD');\n$$\nlanguage sql;\n-- (4)\ncreate or replace function update_motd(request omni_httpd.http_request) returns omni_httpd.http_response as\n$$\ninsert\ninto\nmotd (content)\nvalues\n(convert_from(request.body, 'UTF8'))\nreturning omni_httpd.http_response(status =&gt; 201);\n$$\nlanguage sql;\n-- (5)\nupdate omni_httpd.handlers\nset\nquery = (select\n-- (6)\nomni_httpd.cascading_query(name, query order by priority desc nulls last)\nfrom\n(values\n('show', $$select show_motd() from request where request.method = 'GET'$$, 1),\n('update', $$select update_motd(request.*) from request where request.method = 'POST'$$, 1),\n('fallback', $$select no_motd() from request where request.method = 'GET'$$,\n0)) handlers(name, query, priority));\n</code></pre> <ol> <li>We'll store MOTD here</li> <li>Handles GET request</li> <li>Handles GET request when there is no MOTD</li> <li>Handles POST request</li> <li>Here we update an existing listener's handler. This listener is provisioned    by omni_httpd by default.</li> <li>Cascading queries allow combining multiple handlers into one</li> </ol> <p>It works like this:</p> <pre><code>GET / # =&gt; HTTP/1.1 200 OK\nNo MOTD\n\nPOST / \"Check out Omnigres\" # =&gt; HTTP/1.1 201 OK\nGET / # =&gt; HTTP/1.1 200 OK\nPosted at 2023-03-23 02:59:14.679113\nCheck out Omnigres\n</code></pre>"},{"location":"omni_containers/intro/","title":"Intro","text":"<p>Manages containers that can be automatically connected to the database instance and their lifecycle can be managed from within the database.</p>"},{"location":"omni_ext/intro/","title":"Intro","text":"<p>Omni Extension is a tool for managing Postgres extensions.</p> <ul> <li>Implements Dynpgext interface or restart-free extension installation &amp; upgrades</li> <li>End-to-end SQL interface for extension provisioning</li> <li>Extension dependency resolution</li> </ul>"},{"location":"omni_httpd/headers/","title":"Headers","text":"<p>HTTP requests come with headers, which can be retrieved using <code>omni_httpd.header_get</code> and <code>omni_httpd.header_get_all</code> functions:</p> <pre><code>select omni_httpd.header_get(request.headers, 'host') as host;\nselect omni_httpd.header_get_all(request.headers, 'accept') as accept;\n</code></pre> <p>The header name these functions take is case insensitive.</p>"},{"location":"omni_httpd/intro/","title":"Intro","text":"<p>omni_httpd is an embedded HTTP server for Postgres. It allows one to write HTTP request handling in SQL. This approach lends to less indirection that is common in traditional application architectures, where applications are interacting with the database directly.</p>"},{"location":"omni_httpd/intro/#getting-started","title":"Getting started.","text":"<p>By default, <code>omni_httpd</code>, once installed, will provide a default page on port <code>8080</code>.</p> <p>You can change the handler by updating the <code>query</code> column in the <code>handlers</code> table. Currently, the idiomatic way to write this query is to use <code>omni_httpd.cascading_query</code> aggregate function (though, of course, one can roll their own SQL completely by hand). This function simplifies building priority-sorted request handling:</p> <pre><code>update omni_httpd.handlers\nset\nquery =\n(select\nomni_httpd.cascading_query(name, query order by priority desc nulls last)\nfrom\n(values\n('headers',\n$$select omni_httpd.http_response(body =&gt; request.headers::text) from request where request.path = '/headers'$$,\n1),\n('not_found',\n$$select omni_httpd.http_response(status =&gt; 404, body =&gt; 'Not found') from request$$, 0))\nas routes(name, query, priority));\n</code></pre> What if the query is invalid? <p>omni_httpd enforces validity of the query using a constraint trigger at the transaction boundary when updating or inserting a handler. This means that once the transaction is being committed, the query is validated and if it, say, refers to an unknown relation, column or is invalid for other reasons, it will be rejected and the transaction will not succeed.</p> <p>Please note, however, that at this moment, this enforcement will not help avoiding runtime errors if you render your query invalid afterwards (for example, by dropping relations it references), this will lead to runtime errors, ultimately leading to HTTP 500 responses.</p> <p>The query called <code>headers</code> will dump request's headers, <code>not_found</code> will return HTTP 404. We can test it with <code>curl</code>:</p> <pre><code>$ curl http://localhost:8080\nNot found\n$ curl http://localhost:8080/headers\n{\"(user-agent,curl/7.86.0,t)\",\"(accept,*/*,t)\"}\n</code></pre> <p>The above method of defining the handler can work well when the queries that it is composed of are either stored in a database or can be retrieved during deployment (say, from a Git repository or any other source.)</p> What did you mean by \"priority-sorted\" request handling? <p>If you look at the order of handlers we added (<code>headers</code> followed by <code>not_found</code>), it means that <code>cascading_query</code>-built query will first try to get results from <code>headers</code> and if none available, will attempt <code>not_found</code>. Suppose we changed the order:</p> <pre><code>update omni_httpd.handlers\nset\nquery =\n(select\nomni_httpd.cascading_query(name, query order by priority asc nulls last) -- (1)\nfrom\n(values\n('headers',\n$$select omni_httpd.http_response(body =&gt; request.headers::text) from request where request.path = '/headers'$$,\n1),\n('not_found',\n$$select omni_httpd.http_response(status =&gt; 404, body =&gt; 'Not found') from request$$, 0))\nas routes(name, query, priority));\n</code></pre> <ol> <li>We changed the order from <code>desc</code> to <code>asc</code></li> </ol> <p>Then <code>not_found</code> will always take the precedence:</p> <pre><code>$ curl http://localhost:8080\nNot found\n$ curl http://localhost:8080/headers\nNot found\n</code></pre> <p>Tip</p> <p>An interesting corollary to this approach is that if all of the handling sub-queries are of the same priority, then priority-ordering is not required and one can simply use <code>cascading_query</code> without <code>ORDER BY</code>.</p> What does <code>cascading_query</code> do? <p>The idea behind <code>cascading_query</code> is that it aggregates named queries in a <code>UNION</code> query where all given queries will become common table expressions (CTEs) and the <code>UNION</code> will be used to cascade over them, something like:</p> <pre><code>with\nheaders as (...),\nnot_found as (...)\nselect *\nfrom\nheaders\nunion all\nselect *\nfrom\nnot_found\nwhere\nnot exists(select from headers)\n</code></pre> <p>All good. But looking back into the queries itself, they mention <code>request</code> which is nowhere to be found. Where does this come from? This is actually a CTE that <code>omni_httpd</code> supplies in runtime that has the following <code>omni_httpd.http_request</code> signature:</p> <pre><code>method omni_httpd.http_method,\npath text,\nquery_string text,\nbody bytea,\nheaders omni_httpd.http_header[]\n</code></pre> <p>Tip</p> <p>If this signature seem a little incomplete (where's the source IP address, can the body by streamed, etc.?), that's because it is still work in progress. Please consider contributing if you feel up to it.</p> <p>Also, omni_web provides complementary higher-level functionality.</p>"},{"location":"omni_web/intro/","title":"Intro","text":"<p>omni_web is a library of functions to be used for dealing with the web stack. It's often used together with omni_httpd.</p>"},{"location":"omni_web/query_strings/","title":"Query Strings","text":""},{"location":"omni_web/query_strings/#parsing-query-strings","title":"Parsing query strings","text":"<p><code>parse_query_string</code> takes a query string:</p> <pre><code>select omni_web.parse_query_string('key=value')\n</code></pre> <p>And returns an array of keys and values:</p> <pre><code> parse_query_string --------------------\n{key,value}\n(1 row)\n</code></pre> <p>To retrieve individual parameters, you can use <code>omni_web.param_get</code> and <code>omni_web.param_get_all</code>:</p> <pre><code>select omni_web.param_get(omni_web.parse_query_string('a=1&amp;a=2'), 'a');\nparam_get -----------\n1\n(1 row)\nselect omni_web.param_get_all(omni_web.parse_query_string('a=1&amp;a=2'), 'a');\nparam_get_all\n-----------\n1\n2\n(1 row)\n</code></pre>"}]}